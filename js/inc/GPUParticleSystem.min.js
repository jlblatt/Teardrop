/*
 * GPU Particle System
 * @author flimshaw - Charlie Hoey - http://charliehoey.com
 *
 * A simple to use, general purpose GPU system. Particles are spawn-and-forget with
 * several options available, and do not require monitoring or cleanup after spawning.
 * Because the paths of all particles are completely deterministic once spawned, the scale
 * and direction of time is also variable.
 *
 * Currently uses a static wrapping perlin noise texture for turbulence, and a small png texture for
 * particles, but adding support for a particle texture atlas or changing to a different type of turbulence
 * would be a fairly light day's work.
 *
 * Shader and javascript packing code derrived from several Stack Overflow examples.
 *
 */

 THREE.GPUParticleSystem=function(t){THREE.Object3D.apply(this,arguments),t=t||{},this.PARTICLE_COUNT=t.maxParticles||1e6,this.PARTICLE_CONTAINERS=t.containerCount||1,this.PARTICLE_NOISE_TEXTURE=t.particleNoiseTex||null,this.PARTICLE_SPRITE_TEXTURE=t.particleSpriteTex||null,this.PARTICLES_PER_CONTAINER=Math.ceil(this.PARTICLE_COUNT/this.PARTICLE_CONTAINERS),this.PARTICLE_CURSOR=0,this.time=0,this.particleContainers=[],this.rand=[];var e,i={vertexShader:["uniform float uTime;","uniform float uScale;","uniform sampler2D tNoise;","attribute vec3 positionStart;","attribute float startTime;","attribute vec3 velocity;","attribute float turbulence;","attribute vec3 color;","attribute float size;","attribute float lifeTime;","varying vec4 vColor;","varying float lifeLeft;","void main() {","	vColor = vec4( color, 1.0 );","	vec3 newPosition;","	vec3 v;","	float timeElapsed = uTime - startTime;","	lifeLeft = 1.0 - ( timeElapsed / lifeTime );","	gl_PointSize = ( uScale * size ) * lifeLeft;","	v.x = ( velocity.x - 0.5 ) * 3.0;","	v.y = ( velocity.y - 0.5 ) * 3.0;","	v.z = ( velocity.z - 0.5 ) * 3.0;","	newPosition = positionStart + ( v * 10.0 ) * timeElapsed;","	vec3 noise = texture2D( tNoise, vec2( newPosition.x * 0.015 + ( uTime * 0.05 ), newPosition.y * 0.02 + ( uTime * 0.015 ) ) ).rgb;","	vec3 noiseVel = ( noise.rgb - 0.5 ) * 30.0;","	newPosition = mix( newPosition, newPosition + vec3( noiseVel * ( turbulence * 5.0 ) ), ( timeElapsed / lifeTime ) );","	if( v.y > 0. && v.y < .05 ) {","		lifeLeft = 0.0;","	}","	if( v.x < - 1.45 ) {","		lifeLeft = 0.0;","	}","	if( timeElapsed > 0.0 ) {","		gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );","	} else {","		gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","		lifeLeft = 0.0;","		gl_PointSize = 0.;","	}","}"].join("\n"),fragmentShader:["float scaleLinear( float value, vec2 valueDomain ) {","	return ( value - valueDomain.x ) / ( valueDomain.y - valueDomain.x );","}","float scaleLinear( float value, vec2 valueDomain, vec2 valueRange ) {","	return mix( valueRange.x, valueRange.y, scaleLinear( value, valueDomain ) );","}","varying vec4 vColor;","varying float lifeLeft;","uniform sampler2D tSprite;","void main() {","	float alpha = 0.;","	if( lifeLeft > 0.995 ) {","		alpha = scaleLinear( lifeLeft, vec2( 1.0, 0.995 ), vec2( 0.0, 1.0 ) );","	} else {","		alpha = lifeLeft * 0.75;","	}","	vec4 tex = texture2D( tSprite, gl_PointCoord );","	gl_FragColor = vec4( vColor.rgb * tex.a, alpha * tex.a );","}"].join("\n")};for(e=1e5;e>0;e--)this.rand.push(Math.random()-.5);this.random=function(){return++e>=this.rand.length?this.rand[e=1]:this.rand[e]};var a=new THREE.TextureLoader;this.particleNoiseTex=this.PARTICLE_NOISE_TEXTURE||a.load("textures/perlin-512.png"),this.particleNoiseTex.wrapS=this.particleNoiseTex.wrapT=THREE.RepeatWrapping,this.particleSpriteTex=this.PARTICLE_SPRITE_TEXTURE||a.load("textures/particle2.png"),this.particleSpriteTex.wrapS=this.particleSpriteTex.wrapT=THREE.RepeatWrapping,this.particleShaderMat=new THREE.ShaderMaterial({transparent:!0,depthWrite:!1,uniforms:{uTime:{value:0},uScale:{value:1},tNoise:{value:this.particleNoiseTex},tSprite:{value:this.particleSpriteTex}},blending:THREE.AdditiveBlending,vertexShader:i.vertexShader,fragmentShader:i.fragmentShader}),this.particleShaderMat.defaultAttributeValues.particlePositionsStartTime=[0,0,0,0],this.particleShaderMat.defaultAttributeValues.particleVelColSizeLife=[0,0,0,0],this.init=function(){for(var t=0;t<this.PARTICLE_CONTAINERS;t++){var e=new THREE.GPUParticleContainer(this.PARTICLES_PER_CONTAINER,this);this.particleContainers.push(e),this.add(e)}},this.spawnParticle=function(t){this.PARTICLE_CURSOR++,this.PARTICLE_CURSOR>=this.PARTICLE_COUNT&&(this.PARTICLE_CURSOR=1);var e=this.particleContainers[Math.floor(this.PARTICLE_CURSOR/this.PARTICLES_PER_CONTAINER)];e.spawnParticle(t)},this.update=function(t){for(var e=0;e<this.PARTICLE_CONTAINERS;e++)this.particleContainers[e].update(t)},this.dispose=function(){this.particleShaderMat.dispose(),this.particleNoiseTex.dispose(),this.particleSpriteTex.dispose();for(var t=0;t<this.PARTICLE_CONTAINERS;t++)this.particleContainers[t].dispose()},this.init()},THREE.GPUParticleSystem.prototype=Object.create(THREE.Object3D.prototype),THREE.GPUParticleSystem.prototype.constructor=THREE.GPUParticleSystem,THREE.GPUParticleContainer=function(t,e){THREE.Object3D.apply(this,arguments),this.PARTICLE_COUNT=t||1e5,this.PARTICLE_CURSOR=0,this.time=0,this.offset=0,this.count=0,this.DPR=window.devicePixelRatio,this.GPUParticleSystem=e,this.particleUpdate=!1,this.particleShaderGeo=new THREE.BufferGeometry,this.particleShaderGeo.addAttribute("position",new THREE.BufferAttribute(new Float32Array(3*this.PARTICLE_COUNT),3).setDynamic(!0)),this.particleShaderGeo.addAttribute("positionStart",new THREE.BufferAttribute(new Float32Array(3*this.PARTICLE_COUNT),3).setDynamic(!0)),this.particleShaderGeo.addAttribute("startTime",new THREE.BufferAttribute(new Float32Array(this.PARTICLE_COUNT),1).setDynamic(!0)),this.particleShaderGeo.addAttribute("velocity",new THREE.BufferAttribute(new Float32Array(3*this.PARTICLE_COUNT),3).setDynamic(!0)),this.particleShaderGeo.addAttribute("turbulence",new THREE.BufferAttribute(new Float32Array(this.PARTICLE_COUNT),1).setDynamic(!0)),this.particleShaderGeo.addAttribute("color",new THREE.BufferAttribute(new Float32Array(3*this.PARTICLE_COUNT),3).setDynamic(!0)),this.particleShaderGeo.addAttribute("size",new THREE.BufferAttribute(new Float32Array(this.PARTICLE_COUNT),1).setDynamic(!0)),this.particleShaderGeo.addAttribute("lifeTime",new THREE.BufferAttribute(new Float32Array(this.PARTICLE_COUNT),1).setDynamic(!0)),this.particleShaderMat=this.GPUParticleSystem.particleShaderMat;var i=new THREE.Vector3,a=new THREE.Vector3,r=new THREE.Color;this.spawnParticle=function(t){var o=this.particleShaderGeo.getAttribute("positionStart"),s=this.particleShaderGeo.getAttribute("startTime"),n=this.particleShaderGeo.getAttribute("velocity"),l=this.particleShaderGeo.getAttribute("turbulence"),h=this.particleShaderGeo.getAttribute("color"),c=this.particleShaderGeo.getAttribute("size"),p=this.particleShaderGeo.getAttribute("lifeTime");t=t||{},i=void 0!==t.position?i.copy(t.position):i.set(0,0,0),a=void 0!==t.velocity?a.copy(t.velocity):a.set(0,0,0),r=void 0!==t.color?r.set(t.color):r.set(16777215);var u=void 0!==t.positionRandomness?t.positionRandomness:0,d=void 0!==t.velocityRandomness?t.velocityRandomness:0,R=void 0!==t.colorRandomness?t.colorRandomness:1,f=void 0!==t.turbulence?t.turbulence:1,E=void 0!==t.lifetime?t.lifetime:5,T=void 0!==t.size?t.size:10,m=void 0!==t.sizeRandomness?t.sizeRandomness:0,S=void 0!==t.smoothPosition?t.smoothPosition:!1;void 0!==this.DPR&&(T*=this.DPR);var v=this.PARTICLE_CURSOR;o.array[3*v+0]=i.x+e.random()*u,o.array[3*v+1]=i.y+e.random()*u,o.array[3*v+2]=i.z+e.random()*u,S===!0&&(o.array[3*v+0]+=-(a.x*e.random()),o.array[3*v+1]+=-(a.y*e.random()),o.array[3*v+2]+=-(a.z*e.random()));var C=2,P=a.x+e.random()*d,A=a.y+e.random()*d,y=a.z+e.random()*d;P=THREE.Math.clamp((P- -C)/(C- -C),0,1),A=THREE.Math.clamp((A- -C)/(C- -C),0,1),y=THREE.Math.clamp((y- -C)/(C- -C),0,1),n.array[3*v+0]=P,n.array[3*v+1]=A,n.array[3*v+2]=y,r.r=THREE.Math.clamp(r.r+e.random()*R,0,1),r.g=THREE.Math.clamp(r.g+e.random()*R,0,1),r.b=THREE.Math.clamp(r.b+e.random()*R,0,1),h.array[3*v+0]=r.r,h.array[3*v+1]=r.g,h.array[3*v+2]=r.b,l.array[v]=f,c.array[v]=T+e.random()*m,p.array[v]=E,s.array[v]=this.time+.02*e.random(),0===this.offset&&(this.offset=this.PARTICLE_CURSOR),this.count++,this.PARTICLE_CURSOR++,this.PARTICLE_CURSOR>=this.PARTICLE_COUNT&&(this.PARTICLE_CURSOR=0),this.particleUpdate=!0},this.init=function(){this.particleSystem=new THREE.Points(this.particleShaderGeo,this.particleShaderMat),this.particleSystem.frustumCulled=!1,this.add(this.particleSystem)},this.update=function(t){this.time=t,this.particleShaderMat.uniforms.uTime.value=t,this.geometryUpdate()},this.geometryUpdate=function(){if(this.particleUpdate===!0){this.particleUpdate=!1;var t=this.particleShaderGeo.getAttribute("positionStart"),e=this.particleShaderGeo.getAttribute("startTime"),i=this.particleShaderGeo.getAttribute("velocity"),a=this.particleShaderGeo.getAttribute("turbulence"),r=this.particleShaderGeo.getAttribute("color"),o=this.particleShaderGeo.getAttribute("size"),s=this.particleShaderGeo.getAttribute("lifeTime");this.offset+this.count<this.PARTICLE_COUNT?(t.updateRange.offset=this.offset*t.itemSize,e.updateRange.offset=this.offset*e.itemSize,i.updateRange.offset=this.offset*i.itemSize,a.updateRange.offset=this.offset*a.itemSize,r.updateRange.offset=this.offset*r.itemSize,o.updateRange.offset=this.offset*o.itemSize,s.updateRange.offset=this.offset*s.itemSize,t.updateRange.count=this.count*t.itemSize,e.updateRange.count=this.count*e.itemSize,i.updateRange.count=this.count*i.itemSize,a.updateRange.count=this.count*a.itemSize,r.updateRange.count=this.count*r.itemSize,o.updateRange.count=this.count*o.itemSize,s.updateRange.count=this.count*s.itemSize):(t.updateRange.offset=0,e.updateRange.offset=0,i.updateRange.offset=0,a.updateRange.offset=0,r.updateRange.offset=0,o.updateRange.offset=0,s.updateRange.offset=0,t.updateRange.count=-1,e.updateRange.count=-1,i.updateRange.count=-1,a.updateRange.count=-1,r.updateRange.count=-1,o.updateRange.count=-1,s.updateRange.count=-1),t.needsUpdate=!0,e.needsUpdate=!0,i.needsUpdate=!0,a.needsUpdate=!0,r.needsUpdate=!0,o.needsUpdate=!0,s.needsUpdate=!0,this.offset=0,this.count=0}},this.dispose=function(){this.particleShaderGeo.dispose()},this.init()},THREE.GPUParticleContainer.prototype=Object.create(THREE.Object3D.prototype),THREE.GPUParticleContainer.prototype.constructor=THREE.GPUParticleContainer;